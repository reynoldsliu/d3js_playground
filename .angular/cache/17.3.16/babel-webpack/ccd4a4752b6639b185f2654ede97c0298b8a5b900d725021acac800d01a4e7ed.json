{"ast":null,"code":"import { BehaviorSubject } from 'rxjs';\nimport { v4 as uuidv4 } from 'uuid';\nimport * as i0 from \"@angular/core\";\nexport let TreeDataService = /*#__PURE__*/(() => {\n  class TreeDataService {\n    treeDataSubject = (() => new BehaviorSubject(null))();\n    treeData$ = this.treeDataSubject.asObservable();\n    // 當前選中節點的 BehaviorSubject\n    selectedNodeSubject = (() => new BehaviorSubject(null))();\n    selectedNode$ = this.selectedNodeSubject.asObservable();\n    // 樹狀視圖狀態\n    treeStateSubject = (() => new BehaviorSubject({\n      expandedNodeIds: [],\n      zoom: 1,\n      pan: {\n        x: 0,\n        y: 0\n      }\n    }))();\n    treeState$ = this.treeStateSubject.asObservable();\n    constructor() {}\n    // 載入初始數據\n    loadInitialData(data) {\n      this.treeDataSubject.next(data);\n    }\n    // 選擇節點\n    selectNode(nodeId) {\n      // TODO: 實現選擇節點邏輯\n      const currentData = this.treeDataSubject.getValue();\n      if (!currentData) {\n        return;\n      }\n      // 創建數據的深拷貝以避免直接修改\n      const newData = this.deepCloneTree(currentData);\n      // 重置所有節點的選擇狀態\n      this.resetSelection(newData);\n      // 找到並選中目標節點\n      const targetNode = this.getNodeByIdRecursion(newData, nodeId);\n      if (targetNode) {\n        targetNode.selected = true;\n        // 更新選中節點的主題\n        this.selectedNodeSubject.next(targetNode);\n      }\n      // 發出更新後的樹數據\n      this.treeDataSubject.next(newData);\n    }\n    // 新增節點\n    addNode(parentId, newNode) {\n      // TODO: 實現新增節點邏輯\n      const currentData = this.treeDataSubject.getValue();\n      if (!currentData) {\n        return;\n      }\n      const newData = this.deepCloneTree(currentData);\n      if (parentId) {\n        const targetNode = this.getNodeByIdRecursion(newData, parentId);\n        if (targetNode) {\n          // 初始化 children 陣列如果不存在\n          if (!targetNode.children) {\n            targetNode.children = [];\n          }\n          // 設置正確的 parentId 和 level\n          if (!newNode.id) {\n            newNode.id = this.generateUniqueId();\n          }\n          newNode.parentId = parentId;\n          newNode.level = (targetNode.level || 0) + 1;\n          // 初始化其他屬性\n          newNode.locked = newNode.locked || false;\n          newNode.selected = false; // 新添加的節點通常不會預設為選中狀態\n          newNode.reports = newNode.reports || [];\n          // 添加節點到父節點的 children 中\n          targetNode.children.push(newNode);\n        }\n      } else {\n        // 如果沒有 parentId，則添加為根節點的子節點\n        // 通常這種情況較少見，但處理以防萬一\n        if (!newData.children) {\n          newData.children = [];\n        }\n        // 如果頂層節點沒有 level，初始化為 0\n        if (parentId === null && newData.level === undefined) {\n          newData.level = 0;\n        } else {\n          newNode.level = 1;\n        }\n        newNode.parentId = newData.id;\n        newData.children.push(newNode);\n      }\n      this.treeDataSubject.next(newData);\n    }\n    // 編輯節點\n    updateNode(nodeId, updates) {\n      // TODO: 實現編輯節點邏輯\n      const currentData = this.treeDataSubject.getValue();\n      if (!currentData) {\n        return;\n      }\n      // 創建數據的深拷貝以避免直接修改\n      const newData = this.deepCloneTree(currentData);\n      // 找到並選中目標節點\n      let targetNode = this.getNodeByIdRecursion(newData, nodeId);\n      if (targetNode) {\n        // 更新節點屬性，保留現有屬性\n        Object.assign(targetNode, updates);\n        // 特別處理不應該被覆蓋的屬性\n        if (updates.id && updates.id !== nodeId) {\n          console.warn('不能更改節點ID');\n          targetNode.id = nodeId; // 確保ID不變\n        }\n        // 更新選中節點的主題\n        this.treeDataSubject.next(newData);\n      }\n    }\n    // 刪除節點\n    deleteNode(nodeId) {\n      // TODO: 實現刪除節點邏輯\n      const currentData = this.treeDataSubject.getValue();\n      if (!currentData) {\n        return;\n      }\n      // 不允許刪除根節點\n      if (currentData.id === nodeId) {\n        console.warn('無法刪除根節點');\n        return;\n      }\n      const newData = this.deepCloneTree(currentData);\n      const targetNode = this.getNodeByIdRecursion(newData, nodeId);\n      if (!targetNode) {\n        console.warn('未找到要刪除的節點');\n        return;\n      }\n      // 檢查是否有子節點\n      if (targetNode.children && targetNode.children.length > 0) {\n        console.warn('無法刪除帶有子節點的節點');\n        return;\n      }\n      // 確保有父節點ID\n      if (!targetNode.parentId) {\n        console.warn('節點缺少父節點ID');\n        return;\n      }\n      const parentNode = this.getNodeByIdRecursion(newData, targetNode.parentId);\n      if (parentNode && parentNode.children) {\n        // 從父節點的子節點列表中移除該節點\n        parentNode.children = parentNode.children.filter(node => node.id !== nodeId);\n        // optional: 如果父節點的子節點為空，可以考慮移除children屬性\n        if (parentNode.children.length === 0) {\n          delete parentNode.children;\n        }\n        // 發出更新後的樹\n        this.treeDataSubject.next(newData);\n      } else {\n        console.warn('找不到父節點或父節點沒有子節點');\n      }\n    }\n    // 鎖定/解鎖節點\n    toggleLockNode(nodeId, locked) {\n      // TODO: 實現鎖定/解鎖邏輯\n      const currentData = this.treeDataSubject.getValue();\n      if (!currentData) {\n        return;\n      }\n      const newData = this.deepCloneTree(currentData);\n      const targetNode = this.getNodeByIdRecursion(newData, nodeId);\n      if (targetNode) {\n        targetNode.locked = locked;\n      }\n      // 發出更新後的樹\n      this.treeDataSubject.next(newData);\n    }\n    // 節點關聯\n    linkNodes(sourceId, targetId) {\n      // TODO: 實現節點關聯邏輯\n      const currentData = this.treeDataSubject.getValue();\n      if (!currentData || sourceId === targetId) {\n        return;\n      }\n      const newData = this.deepCloneTree(currentData);\n      const sourceNode = this.getNodeByIdRecursion(newData, sourceId);\n      if (sourceNode) {\n        if (!sourceNode.relatedTo) {\n          sourceNode.relatedTo = [];\n        }\n        if (!sourceNode.relatedTo.includes(targetId)) {\n          sourceNode.relatedTo?.push(targetId);\n        } else {\n          console.warn('關聯已存在');\n        }\n      } else {\n        console.warn('找不到節點' + sourceId);\n      }\n      const targetNode = this.getNodeByIdRecursion(newData, targetId);\n      if (targetNode) {\n        if (!targetNode.relatedTo) {\n          targetNode.relatedTo = [];\n        }\n        if (!targetNode.relatedTo.includes(sourceId)) {\n          targetNode.relatedTo?.push(sourceId);\n        } else {\n          console.warn('關聯已存在');\n        }\n      } else {\n        console.warn('找不到節點' + targetId);\n      }\n      // 發出更新後的樹\n      this.treeDataSubject.next(newData);\n    }\n    // 取消節點關聯\n    unlinkNodes(sourceId, targetId) {\n      // TODO: 實現取消節點關聯邏輯\n      const currentData = this.treeDataSubject.getValue();\n      if (!currentData || sourceId === targetId) {\n        return;\n      }\n      const newData = this.deepCloneTree(currentData);\n      const sourceNode = this.getNodeByIdRecursion(newData, sourceId);\n      if (sourceNode) {\n        if (sourceNode.relatedTo && sourceNode.relatedTo.includes(targetId)) {\n          sourceNode.relatedTo = sourceNode.relatedTo.filter(r => r !== targetId);\n          if (sourceNode.relatedTo.length === 0) {\n            delete sourceNode.relatedTo;\n          }\n        } else {\n          console.warn('找不到已存在關聯' + sourceId);\n        }\n      } else {\n        console.warn('找不到節點' + sourceId);\n      }\n      const targetNode = this.getNodeByIdRecursion(newData, targetId);\n      if (targetNode) {\n        if (targetNode.relatedTo && targetNode.relatedTo.includes(sourceId)) {\n          targetNode.relatedTo = targetNode.relatedTo.filter(r => r !== sourceId);\n          if (targetNode.relatedTo.length === 0) {\n            delete targetNode.relatedTo;\n          }\n        } else {\n          console.warn('找不到已存在關聯' + targetId);\n        }\n      } else {\n        console.warn('找不到節點' + targetId);\n      }\n      // 發出更新後的樹\n      this.treeDataSubject.next(newData);\n    }\n    // 查找相同名稱的節點\n    findNodesByName(name) {\n      // TODO: 實現查找相同名稱節點的邏輯\n      const currentData = this.treeDataSubject.getValue();\n      if (!currentData) {\n        return [];\n      }\n      // 不需要複製數據，因為我們只是讀取，不修改\n      const result = [];\n      this.collectNodesByName(currentData, name, result);\n      return result;\n    }\n    // 獲取當前樹狀視圖狀態\n    getTreeState() {\n      return this.treeStateSubject.getValue();\n    }\n    // 更新樹狀視圖狀態\n    updateTreeState(updates) {\n      this.treeStateSubject.next({\n        ...this.treeStateSubject.getValue(),\n        ...updates\n      });\n    }\n    getNodeByIdRecursion(root, nodeId) {\n      // 先檢查當前節點\n      if (root.id === nodeId) {\n        return root;\n      }\n      // 如果有子節點，遞迴搜尋\n      if (root.children && root.children.length > 0) {\n        for (const child of root.children) {\n          const found = this.getNodeByIdRecursion(child, nodeId);\n          if (found) {\n            return found;\n          }\n        }\n      }\n      // 未找到\n      return null;\n    }\n    collectNodesByName(root, matchName, collected) {\n      // 檢查當前節點名稱是否匹配\n      if (node.name === matchName) {\n        result.push(node);\n      }\n      // 遞迴檢查所有子節點\n      if (node.children && node.children.length > 0) {\n        for (const child of node.children) {\n          this.collectNodesByName(child, matchName, result);\n        }\n      }\n    }\n    // 重置所有節點的選擇狀態\n    resetSelection(node) {\n      node.selected = false;\n      if (node.children) {\n        node.children.forEach(child => this.resetSelection(child));\n      }\n    }\n    // 深拷貝樹\n    deepCloneTree(node) {\n      const clone = {\n        ...node\n      };\n      if (node.children) {\n        clone.children = node.children.map(child => this.deepCloneTree(child));\n      }\n      return clone;\n    }\n    generateUniqueId() {\n      return uuidv4();\n    }\n    static ɵfac = function TreeDataService_Factory(t) {\n      return new (t || TreeDataService)();\n    };\n    static ɵprov = (() => /*@__PURE__*/i0.ɵɵdefineInjectable({\n      token: TreeDataService,\n      factory: TreeDataService.ɵfac,\n      providedIn: 'root'\n    }))();\n  }\n  return TreeDataService;\n})();","map":{"version":3,"names":["BehaviorSubject","v4","uuidv4","TreeDataService","treeDataSubject","treeData$","asObservable","selectedNodeSubject","selectedNode$","treeStateSubject","expandedNodeIds","zoom","pan","x","y","treeState$","constructor","loadInitialData","data","next","selectNode","nodeId","currentData","getValue","newData","deepCloneTree","resetSelection","targetNode","getNodeByIdRecursion","selected","addNode","parentId","newNode","children","id","generateUniqueId","level","locked","reports","push","undefined","updateNode","updates","Object","assign","console","warn","deleteNode","length","parentNode","filter","node","toggleLockNode","linkNodes","sourceId","targetId","sourceNode","relatedTo","includes","unlinkNodes","r","findNodesByName","name","result","collectNodesByName","getTreeState","updateTreeState","root","child","found","matchName","collected","forEach","clone","map","factory","ɵfac","providedIn"],"sources":["/Users/reynolds/cursor/d3js_example2/angular8-app/src/app/services/tree-data-service.ts"],"sourcesContent":["import {Injectable} from '@angular/core';\nimport {BehaviorSubject} from 'rxjs';\nimport {TreeNode, TreeState} from '../interfaces/interfaces';\nimport {v4 as uuidv4} from 'uuid';\n\n@Injectable({providedIn: 'root'})\nexport class TreeDataService {\n  private treeDataSubject = new BehaviorSubject<TreeNode | null>(null);\n  treeData$ = this.treeDataSubject.asObservable();\n\n  // 當前選中節點的 BehaviorSubject\n  private selectedNodeSubject = new BehaviorSubject<TreeNode | null>(null);\n  selectedNode$ = this.selectedNodeSubject.asObservable();\n\n  // 樹狀視圖狀態\n  private treeStateSubject = new BehaviorSubject<TreeState>({\n    expandedNodeIds: [],\n    zoom: 1,\n    pan: {x: 0, y: 0}\n  });\n  treeState$ = this.treeStateSubject.asObservable();\n\n  constructor() {\n  }\n\n  // 載入初始數據\n  loadInitialData(data: TreeNode): void {\n    this.treeDataSubject.next(data);\n  }\n\n  // 選擇節點\n  selectNode(nodeId: string): void {\n    // TODO: 實現選擇節點邏輯\n    const currentData = this.treeDataSubject.getValue();\n    if (!currentData) {\n      return;\n    }\n\n    // 創建數據的深拷貝以避免直接修改\n    const newData = this.deepCloneTree(currentData);\n\n    // 重置所有節點的選擇狀態\n    this.resetSelection(newData);\n\n    // 找到並選中目標節點\n    const targetNode = this.getNodeByIdRecursion(newData, nodeId);\n    if (targetNode) {\n      targetNode.selected = true;\n      // 更新選中節點的主題\n      this.selectedNodeSubject.next(targetNode);\n    }\n\n    // 發出更新後的樹數據\n    this.treeDataSubject.next(newData);\n  }\n\n  // 新增節點\n  addNode(parentId: string | null, newNode: TreeNode): void {\n    // TODO: 實現新增節點邏輯\n    const currentData = this.treeDataSubject.getValue();\n    if (!currentData) {\n      return;\n    }\n\n    const newData = this.deepCloneTree(currentData);\n    if (parentId) {\n      const targetNode = this.getNodeByIdRecursion(newData, parentId);\n      if (targetNode) {\n        // 初始化 children 陣列如果不存在\n        if (!targetNode.children) {\n          targetNode.children = [];\n        }\n        // 設置正確的 parentId 和 level\n        if (!newNode.id) {\n          newNode.id = this.generateUniqueId();\n        }\n        newNode.parentId = parentId;\n        newNode.level = (targetNode.level || 0) + 1;\n        // 初始化其他屬性\n        newNode.locked = newNode.locked || false;\n        newNode.selected = false; // 新添加的節點通常不會預設為選中狀態\n        newNode.reports = newNode.reports || [];\n\n        // 添加節點到父節點的 children 中\n        targetNode.children.push(newNode);\n      }\n    } else {\n      // 如果沒有 parentId，則添加為根節點的子節點\n      // 通常這種情況較少見，但處理以防萬一\n      if (!newData.children) {\n        newData.children = [];\n      }\n\n      // 如果頂層節點沒有 level，初始化為 0\n      if (parentId === null && newData.level === undefined) {\n        newData.level = 0;\n      } else {\n        newNode.level = 1;\n      }\n      newNode.parentId = newData.id;\n      newData.children.push(newNode);\n    }\n\n    this.treeDataSubject.next(newData);\n  }\n\n  // 編輯節點\n  updateNode(nodeId: string, updates: TreeNode): void {\n    // TODO: 實現編輯節點邏輯\n    const currentData = this.treeDataSubject.getValue();\n    if (!currentData) {\n      return;\n    }\n\n    // 創建數據的深拷貝以避免直接修改\n    const newData = this.deepCloneTree(currentData);\n    // 找到並選中目標節點\n    let targetNode = this.getNodeByIdRecursion(newData, nodeId);\n    if (targetNode) {\n      // 更新節點屬性，保留現有屬性\n      Object.assign(targetNode, updates);\n\n      // 特別處理不應該被覆蓋的屬性\n      if (updates.id && updates.id !== nodeId) {\n        console.warn('不能更改節點ID');\n        targetNode.id = nodeId; // 確保ID不變\n      }\n      // 更新選中節點的主題\n      this.treeDataSubject.next(newData);\n    }\n  }\n\n  // 刪除節點\n  deleteNode(nodeId: string): void {\n    // TODO: 實現刪除節點邏輯\n    const currentData = this.treeDataSubject.getValue();\n    if (!currentData) {\n      return;\n    }\n\n    // 不允許刪除根節點\n    if (currentData.id === nodeId) {\n      console.warn('無法刪除根節點');\n      return;\n    }\n\n    const newData = this.deepCloneTree(currentData);\n    const targetNode = this.getNodeByIdRecursion(newData, nodeId);\n\n    if (!targetNode) {\n      console.warn('未找到要刪除的節點');\n      return;\n    }\n\n    // 檢查是否有子節點\n    if (targetNode.children && targetNode.children.length > 0) {\n      console.warn('無法刪除帶有子節點的節點');\n      return;\n    }\n\n    // 確保有父節點ID\n    if (!targetNode.parentId) {\n      console.warn('節點缺少父節點ID');\n      return;\n    }\n\n    const parentNode = this.getNodeByIdRecursion(newData, targetNode.parentId);\n    if (parentNode && parentNode.children) {\n      // 從父節點的子節點列表中移除該節點\n      parentNode.children = parentNode.children.filter(node => node.id !== nodeId);\n\n      // optional: 如果父節點的子節點為空，可以考慮移除children屬性\n      if (parentNode.children.length === 0) {\n        delete parentNode.children;\n      }\n\n      // 發出更新後的樹\n      this.treeDataSubject.next(newData);\n    } else {\n      console.warn('找不到父節點或父節點沒有子節點');\n    }\n  }\n\n  // 鎖定/解鎖節點\n  toggleLockNode(nodeId: string, locked: boolean): void {\n    // TODO: 實現鎖定/解鎖邏輯\n    const currentData = this.treeDataSubject.getValue();\n    if (!currentData) {\n      return;\n    }\n    const newData = this.deepCloneTree(currentData);\n    const targetNode = this.getNodeByIdRecursion(newData, nodeId);\n    if (targetNode) {\n      targetNode.locked = locked;\n    }\n    // 發出更新後的樹\n    this.treeDataSubject.next(newData);\n  }\n\n  // 節點關聯\n  linkNodes(sourceId: string, targetId: string): void {\n    // TODO: 實現節點關聯邏輯\n    const currentData = this.treeDataSubject.getValue();\n    if (!currentData || sourceId === targetId) {\n      return;\n    }\n    const newData = this.deepCloneTree(currentData);\n    const sourceNode = this.getNodeByIdRecursion(newData, sourceId);\n    if (sourceNode) {\n      if (!sourceNode.relatedTo) {\n        sourceNode.relatedTo = [];\n      }\n      if (!sourceNode.relatedTo.includes(targetId)) {\n        sourceNode.relatedTo?.push(targetId);\n      } else {\n        console.warn('關聯已存在');\n      }\n    } else {\n      console.warn('找不到節點' + sourceId);\n    }\n    const targetNode = this.getNodeByIdRecursion(newData, targetId);\n    if (targetNode) {\n      if (!targetNode.relatedTo) {\n        targetNode.relatedTo = [];\n      }\n      if (!targetNode.relatedTo.includes(sourceId)) {\n        targetNode.relatedTo?.push(sourceId);\n      } else {\n        console.warn('關聯已存在');\n      }\n    } else {\n      console.warn('找不到節點' + targetId);\n    }\n    // 發出更新後的樹\n    this.treeDataSubject.next(newData);\n  }\n\n  // 取消節點關聯\n  unlinkNodes(sourceId: string, targetId: string): void {\n    // TODO: 實現取消節點關聯邏輯\n    const currentData = this.treeDataSubject.getValue();\n    if (!currentData || sourceId === targetId) {\n      return;\n    }\n    const newData = this.deepCloneTree(currentData);\n    const sourceNode = this.getNodeByIdRecursion(newData, sourceId);\n    if (sourceNode) {\n      if (sourceNode.relatedTo && sourceNode.relatedTo.includes(targetId)) {\n        sourceNode.relatedTo = sourceNode.relatedTo.filter(r => r !== targetId);\n        if (sourceNode.relatedTo.length === 0) {\n          delete sourceNode.relatedTo;\n        }\n      } else {\n        console.warn('找不到已存在關聯' + sourceId);\n      }\n    } else {\n      console.warn('找不到節點' + sourceId);\n    }\n    const targetNode = this.getNodeByIdRecursion(newData, targetId);\n    if (targetNode) {\n      if (targetNode.relatedTo && targetNode.relatedTo.includes(sourceId)) {\n        targetNode.relatedTo = targetNode.relatedTo.filter(r => r !== sourceId);\n        if (targetNode.relatedTo.length === 0) {\n          delete targetNode.relatedTo;\n        }\n      } else {\n        console.warn('找不到已存在關聯' + targetId);\n      }\n    } else {\n      console.warn('找不到節點' + targetId);\n    }\n// 發出更新後的樹\n    this.treeDataSubject.next(newData);\n  }\n\n  // 查找相同名稱的節點\n  findNodesByName(name: string): TreeNode[] {\n    // TODO: 實現查找相同名稱節點的邏輯\n    const currentData = this.treeDataSubject.getValue();\n    if (!currentData) {\n      return [];\n    }\n\n    // 不需要複製數據，因為我們只是讀取，不修改\n    const result: TreeNode[] = [];\n    this.collectNodesByName(currentData, name, result);\n    return result;\n  }\n\n  // 獲取當前樹狀視圖狀態\n  getTreeState(): TreeState {\n    return this.treeStateSubject.getValue();\n  }\n\n  // 更新樹狀視圖狀態\n  updateTreeState(updates: Partial<TreeState>): void {\n    this.treeStateSubject.next({\n      ...this.treeStateSubject.getValue(),\n      ...updates\n    });\n  }\n\n  getNodeByIdRecursion(root: TreeNode, nodeId: string): TreeNode | null {\n    // 先檢查當前節點\n    if (root.id === nodeId) {\n      return root;\n    }\n\n    // 如果有子節點，遞迴搜尋\n    if (root.children && root.children.length > 0) {\n      for (const child of root.children) {\n        const found = this.getNodeByIdRecursion(child, nodeId);\n        if (found) {\n          return found;\n        }\n      }\n    }\n\n    // 未找到\n    return null;\n  }\n\n  collectNodesByName(root: TreeNode, matchName: string, collected: TreeNode[]): TreeNode[] {\n    // 檢查當前節點名稱是否匹配\n    if (node.name === matchName) {\n      result.push(node);\n    }\n\n    // 遞迴檢查所有子節點\n    if (node.children && node.children.length > 0) {\n      for (const child of node.children) {\n        this.collectNodesByName(child, matchName, result);\n      }\n    }\n  }\n\n  // 重置所有節點的選擇狀態\n  private resetSelection(node: TreeNode): void {\n    node.selected = false;\n    if (node.children) {\n      node.children.forEach(child => this.resetSelection(child));\n    }\n  }\n\n// 深拷貝樹\n  private deepCloneTree(node: TreeNode): TreeNode {\n    const clone = {...node};\n    if (node.children) {\n      clone.children = node.children.map(child => this.deepCloneTree(child));\n    }\n    return clone;\n  }\n\n  private generateUniqueId(): string {\n    return uuidv4();\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}