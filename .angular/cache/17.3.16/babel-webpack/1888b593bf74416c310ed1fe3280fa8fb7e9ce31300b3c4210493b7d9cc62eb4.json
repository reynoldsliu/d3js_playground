{"ast":null,"code":"import { BehaviorSubject } from 'rxjs';\nimport * as i0 from \"@angular/core\";\nexport let TreeDataService = /*#__PURE__*/(() => {\n  class TreeDataService {\n    treeDataSubject = (() => new BehaviorSubject(null))();\n    treeData$ = this.treeDataSubject.asObservable();\n    // 當前選中節點的 BehaviorSubject\n    selectedNodeSubject = (() => new BehaviorSubject(null))();\n    selectedNode$ = this.selectedNodeSubject.asObservable();\n    // 樹狀視圖狀態\n    treeStateSubject = (() => new BehaviorSubject({\n      expandedNodeIds: [],\n      zoom: 1,\n      pan: {\n        x: 0,\n        y: 0\n      }\n    }))();\n    treeState$ = this.treeStateSubject.asObservable();\n    constructor() {}\n    // 載入初始數據\n    loadInitialData(data) {\n      this.treeDataSubject.next(data);\n    }\n    // 選擇節點\n    selectNode(nodeId) {\n      // TODO: 實現選擇節點邏輯\n      const currentData = this.treeDataSubject.getValue();\n      if (!currentData) return;\n      // 創建數據的深拷貝以避免直接修改\n      const newData = this.deepCloneTree(currentData);\n      // 重置所有節點的選擇狀態\n      this.resetSelection(newData);\n      // 找到並選中目標節點\n      const targetNode = this.getNodeByIdRecursion(newData, nodeId);\n      if (targetNode) {\n        targetNode.selected = true;\n        // 更新選中節點的主題\n        this.selectedNodeSubject.next(targetNode);\n      }\n      // 發出更新後的樹數據\n      this.treeDataSubject.next(newData);\n    }\n    // 新增節點\n    addNode(parentId, newNode) {\n      // TODO: 實現新增節點邏輯\n      this.treeData$.subscribe(root => {\n        if (root && parentId) {\n          const node = this.getNodeByIdRecursion(root, parentId);\n          if (node) {\n            node.children?.push(newNode);\n          }\n        }\n      });\n    }\n    // 編輯節點\n    updateNode(nodeId, updates) {\n      // TODO: 實現編輯節點邏輯\n    }\n    // 刪除節點\n    deleteNode(nodeId) {\n      // TODO: 實現刪除節點邏輯\n    }\n    // 鎖定/解鎖節點\n    toggleLockNode(nodeId, locked) {\n      // TODO: 實現鎖定/解鎖邏輯\n    }\n    // 節點關聯\n    linkNodes(sourceId, targetId) {\n      // TODO: 實現節點關聯邏輯\n    }\n    // 取消節點關聯\n    unlinkNodes(sourceId, targetId) {\n      // TODO: 實現取消節點關聯邏輯\n    }\n    // 查找相同名稱的節點\n    findNodesByName(name) {\n      // TODO: 實現查找相同名稱節點的邏輯\n      return [];\n    }\n    // 獲取當前樹狀視圖狀態\n    getTreeState() {\n      return this.treeStateSubject.getValue();\n    }\n    // 更新樹狀視圖狀態\n    updateTreeState(updates) {\n      this.treeStateSubject.next({\n        ...this.treeStateSubject.getValue(),\n        ...updates\n      });\n    }\n    getNodeByIdRecursion(root, nodeId) {\n      // 先檢查當前節點\n      if (root.id === nodeId) {\n        return root;\n      }\n      // 如果有子節點，遞迴搜尋\n      if (root.children && root.children.length > 0) {\n        for (const child of root.children) {\n          const found = this.getNodeByIdRecursion(child, nodeId);\n          if (found) return found;\n        }\n      }\n      // 未找到\n      return null;\n    }\n    // 重置所有節點的選擇狀態\n    resetSelection(node) {\n      node.selected = false;\n      if (node.children) {\n        node.children.forEach(child => this.resetSelection(child));\n      }\n    }\n    // 深拷貝樹\n    deepCloneTree(node) {\n      const clone = {\n        ...node\n      };\n      if (node.children) {\n        clone.children = node.children.map(child => this.deepCloneTree(child));\n      }\n      return clone;\n    }\n    static ɵfac = function TreeDataService_Factory(t) {\n      return new (t || TreeDataService)();\n    };\n    static ɵprov = (() => /*@__PURE__*/i0.ɵɵdefineInjectable({\n      token: TreeDataService,\n      factory: TreeDataService.ɵfac,\n      providedIn: 'root'\n    }))();\n  }\n  return TreeDataService;\n})();","map":{"version":3,"names":["BehaviorSubject","TreeDataService","treeDataSubject","treeData$","asObservable","selectedNodeSubject","selectedNode$","treeStateSubject","expandedNodeIds","zoom","pan","x","y","treeState$","constructor","loadInitialData","data","next","selectNode","nodeId","currentData","getValue","newData","deepCloneTree","resetSelection","targetNode","getNodeByIdRecursion","selected","addNode","parentId","newNode","subscribe","root","node","children","push","updateNode","updates","deleteNode","toggleLockNode","locked","linkNodes","sourceId","targetId","unlinkNodes","findNodesByName","name","getTreeState","updateTreeState","id","length","child","found","forEach","clone","map","factory","ɵfac","providedIn"],"sources":["/Users/reynolds/cursor/d3js_example2/angular8-app/src/app/services/tree-data-service.ts"],"sourcesContent":["import {Injectable} from '@angular/core';\nimport {BehaviorSubject} from 'rxjs';\nimport {TreeNode, TreeState} from '../interfaces/interfaces';\n\n@Injectable({providedIn: 'root'})\nexport class TreeDataService {\n  private treeDataSubject = new BehaviorSubject<TreeNode | null>(null);\n  treeData$ = this.treeDataSubject.asObservable();\n\n  // 當前選中節點的 BehaviorSubject\n  private selectedNodeSubject = new BehaviorSubject<TreeNode | null>(null);\n  selectedNode$ = this.selectedNodeSubject.asObservable();\n\n  // 樹狀視圖狀態\n  private treeStateSubject = new BehaviorSubject<TreeState>({\n    expandedNodeIds: [],\n    zoom: 1,\n    pan: {x: 0, y: 0}\n  });\n  treeState$ = this.treeStateSubject.asObservable();\n\n  constructor() {\n  }\n\n  // 載入初始數據\n  loadInitialData(data: TreeNode): void {\n    this.treeDataSubject.next(data);\n  }\n\n  // 選擇節點\n  selectNode(nodeId: string): void {\n    // TODO: 實現選擇節點邏輯\n    const currentData = this.treeDataSubject.getValue();\n    if (!currentData) return;\n\n    // 創建數據的深拷貝以避免直接修改\n    const newData = this.deepCloneTree(currentData);\n\n    // 重置所有節點的選擇狀態\n    this.resetSelection(newData);\n\n    // 找到並選中目標節點\n    const targetNode = this.getNodeByIdRecursion(newData, nodeId);\n    if (targetNode) {\n      targetNode.selected = true;\n      // 更新選中節點的主題\n      this.selectedNodeSubject.next(targetNode);\n    }\n\n    // 發出更新後的樹數據\n    this.treeDataSubject.next(newData);\n  }\n\n  // 新增節點\n  addNode(parentId: string | null, newNode: TreeNode): void {\n    // TODO: 實現新增節點邏輯\n    this.treeData$.subscribe((root: TreeNode | null) => {\n      if (root && parentId) {\n        const node = this.getNodeByIdRecursion(root, parentId);\n        if (node) {\n          node.children?.push(newNode);\n        }\n      }\n    });\n  }\n\n  // 編輯節點\n  updateNode(nodeId: string, updates: Partial<TreeNode>): void {\n    // TODO: 實現編輯節點邏輯\n  }\n\n  // 刪除節點\n  deleteNode(nodeId: string): void {\n    // TODO: 實現刪除節點邏輯\n  }\n\n  // 鎖定/解鎖節點\n  toggleLockNode(nodeId: string, locked: boolean): void {\n    // TODO: 實現鎖定/解鎖邏輯\n  }\n\n  // 節點關聯\n  linkNodes(sourceId: string, targetId: string): void {\n    // TODO: 實現節點關聯邏輯\n  }\n\n  // 取消節點關聯\n  unlinkNodes(sourceId: string, targetId: string): void {\n    // TODO: 實現取消節點關聯邏輯\n  }\n\n  // 查找相同名稱的節點\n  findNodesByName(name: string): TreeNode[] {\n    // TODO: 實現查找相同名稱節點的邏輯\n    return [];\n  }\n\n  // 獲取當前樹狀視圖狀態\n  getTreeState(): TreeState {\n    return this.treeStateSubject.getValue();\n  }\n\n  // 更新樹狀視圖狀態\n  updateTreeState(updates: Partial<TreeState>): void {\n    this.treeStateSubject.next({\n      ...this.treeStateSubject.getValue(),\n      ...updates\n    });\n  }\n\n  getNodeByIdRecursion(root: TreeNode, nodeId: string): TreeNode | null {\n    // 先檢查當前節點\n    if (root.id === nodeId) {\n      return root;\n    }\n\n    // 如果有子節點，遞迴搜尋\n    if (root.children && root.children.length > 0) {\n      for (const child of root.children) {\n        const found = this.getNodeByIdRecursion(child, nodeId);\n        if (found) return found;\n      }\n    }\n\n    // 未找到\n    return null;\n  }\n\n  // 重置所有節點的選擇狀態\n  private resetSelection(node: TreeNode): void {\n    node.selected = false;\n    if (node.children) {\n      node.children.forEach(child => this.resetSelection(child));\n    }\n  }\n\n// 深拷貝樹\n  private deepCloneTree(node: TreeNode): TreeNode {\n    const clone = { ...node };\n    if (node.children) {\n      clone.children = node.children.map(child => this.deepCloneTree(child));\n    }\n    return clone;\n  }\n}\n"],"mappings":"AACA,SAAQA,eAAe,QAAO,MAAM;;AAIpC,WAAaC,eAAe;EAAtB,MAAOA,eAAe;IAClBC,eAAe,UAAG,IAAIF,eAAe,CAAkB,IAAI,CAAC;IACpEG,SAAS,GAAG,IAAI,CAACD,eAAe,CAACE,YAAY,EAAE;IAE/C;IACQC,mBAAmB,UAAG,IAAIL,eAAe,CAAkB,IAAI,CAAC;IACxEM,aAAa,GAAG,IAAI,CAACD,mBAAmB,CAACD,YAAY,EAAE;IAEvD;IACQG,gBAAgB,UAAG,IAAIP,eAAe,CAAY;MACxDQ,eAAe,EAAE,EAAE;MACnBC,IAAI,EAAE,CAAC;MACPC,GAAG,EAAE;QAACC,CAAC,EAAE,CAAC;QAAEC,CAAC,EAAE;MAAC;KACjB,CAAC;IACFC,UAAU,GAAG,IAAI,CAACN,gBAAgB,CAACH,YAAY,EAAE;IAEjDU,YAAA,GACA;IAEA;IACAC,eAAeA,CAACC,IAAc;MAC5B,IAAI,CAACd,eAAe,CAACe,IAAI,CAACD,IAAI,CAAC;IACjC;IAEA;IACAE,UAAUA,CAACC,MAAc;MACvB;MACA,MAAMC,WAAW,GAAG,IAAI,CAAClB,eAAe,CAACmB,QAAQ,EAAE;MACnD,IAAI,CAACD,WAAW,EAAE;MAElB;MACA,MAAME,OAAO,GAAG,IAAI,CAACC,aAAa,CAACH,WAAW,CAAC;MAE/C;MACA,IAAI,CAACI,cAAc,CAACF,OAAO,CAAC;MAE5B;MACA,MAAMG,UAAU,GAAG,IAAI,CAACC,oBAAoB,CAACJ,OAAO,EAAEH,MAAM,CAAC;MAC7D,IAAIM,UAAU,EAAE;QACdA,UAAU,CAACE,QAAQ,GAAG,IAAI;QAC1B;QACA,IAAI,CAACtB,mBAAmB,CAACY,IAAI,CAACQ,UAAU,CAAC;MAC3C;MAEA;MACA,IAAI,CAACvB,eAAe,CAACe,IAAI,CAACK,OAAO,CAAC;IACpC;IAEA;IACAM,OAAOA,CAACC,QAAuB,EAAEC,OAAiB;MAChD;MACA,IAAI,CAAC3B,SAAS,CAAC4B,SAAS,CAAEC,IAAqB,IAAI;QACjD,IAAIA,IAAI,IAAIH,QAAQ,EAAE;UACpB,MAAMI,IAAI,GAAG,IAAI,CAACP,oBAAoB,CAACM,IAAI,EAAEH,QAAQ,CAAC;UACtD,IAAII,IAAI,EAAE;YACRA,IAAI,CAACC,QAAQ,EAAEC,IAAI,CAACL,OAAO,CAAC;UAC9B;QACF;MACF,CAAC,CAAC;IACJ;IAEA;IACAM,UAAUA,CAACjB,MAAc,EAAEkB,OAA0B;MACnD;IAAA;IAGF;IACAC,UAAUA,CAACnB,MAAc;MACvB;IAAA;IAGF;IACAoB,cAAcA,CAACpB,MAAc,EAAEqB,MAAe;MAC5C;IAAA;IAGF;IACAC,SAASA,CAACC,QAAgB,EAAEC,QAAgB;MAC1C;IAAA;IAGF;IACAC,WAAWA,CAACF,QAAgB,EAAEC,QAAgB;MAC5C;IAAA;IAGF;IACAE,eAAeA,CAACC,IAAY;MAC1B;MACA,OAAO,EAAE;IACX;IAEA;IACAC,YAAYA,CAAA;MACV,OAAO,IAAI,CAACxC,gBAAgB,CAACc,QAAQ,EAAE;IACzC;IAEA;IACA2B,eAAeA,CAACX,OAA2B;MACzC,IAAI,CAAC9B,gBAAgB,CAACU,IAAI,CAAC;QACzB,GAAG,IAAI,CAACV,gBAAgB,CAACc,QAAQ,EAAE;QACnC,GAAGgB;OACJ,CAAC;IACJ;IAEAX,oBAAoBA,CAACM,IAAc,EAAEb,MAAc;MACjD;MACA,IAAIa,IAAI,CAACiB,EAAE,KAAK9B,MAAM,EAAE;QACtB,OAAOa,IAAI;MACb;MAEA;MACA,IAAIA,IAAI,CAACE,QAAQ,IAAIF,IAAI,CAACE,QAAQ,CAACgB,MAAM,GAAG,CAAC,EAAE;QAC7C,KAAK,MAAMC,KAAK,IAAInB,IAAI,CAACE,QAAQ,EAAE;UACjC,MAAMkB,KAAK,GAAG,IAAI,CAAC1B,oBAAoB,CAACyB,KAAK,EAAEhC,MAAM,CAAC;UACtD,IAAIiC,KAAK,EAAE,OAAOA,KAAK;QACzB;MACF;MAEA;MACA,OAAO,IAAI;IACb;IAEA;IACQ5B,cAAcA,CAACS,IAAc;MACnCA,IAAI,CAACN,QAAQ,GAAG,KAAK;MACrB,IAAIM,IAAI,CAACC,QAAQ,EAAE;QACjBD,IAAI,CAACC,QAAQ,CAACmB,OAAO,CAACF,KAAK,IAAI,IAAI,CAAC3B,cAAc,CAAC2B,KAAK,CAAC,CAAC;MAC5D;IACF;IAEF;IACU5B,aAAaA,CAACU,IAAc;MAClC,MAAMqB,KAAK,GAAG;QAAE,GAAGrB;MAAI,CAAE;MACzB,IAAIA,IAAI,CAACC,QAAQ,EAAE;QACjBoB,KAAK,CAACpB,QAAQ,GAAGD,IAAI,CAACC,QAAQ,CAACqB,GAAG,CAACJ,KAAK,IAAI,IAAI,CAAC5B,aAAa,CAAC4B,KAAK,CAAC,CAAC;MACxE;MACA,OAAOG,KAAK;IACd;;uBA1IWrD,eAAe;IAAA;;aAAfA,eAAe;MAAAuD,OAAA,EAAfvD,eAAe,CAAAwD,IAAA;MAAAC,UAAA,EADH;IAAM;;SAClBzD,eAAe;AAAA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}